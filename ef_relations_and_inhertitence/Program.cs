// See https://aka.ms/new-console-template for more information
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

Console.WriteLine("Hello, World!");
/**
 Steps for starting from scratch with EF(up and runing)
1. nuget pack in order to project work with ef
-design - all design capabilities of ef add to your app(migrations)
-dbProvider - depending of the db you use
****if we not in asp framework we need 2 additional packeges
-extension.configiration.json - reading of connstring from appsettings.json(loosly related to ef, you cuold also type in connstring but not good)
-logging console - sql statement generated by ef
all dependencies needed for console app to work with ef
2. building data model(domain class,model) including relations
3. creation of dbcontext and dbfactory(automated in asp)
4. create db through migrations(and than fill it and query it)
 * **/

var factory = new BrickContextFactory();
using var context = factory.CreateDbContext();
await AddData();
static async Task AddData()
{
    //Vendor brickKing, heldDerSteine;
    //await context.AddRangeAsync(new
    //{
    //    brickKing = new Vendor{VendorName = "Brick King",}
    //    brickKing = new Vendor{VendorName =  "heldDerSteine", }
    //});
}

#region Models
//in db this will become int(ef stores enum like that) and it reflect the int behind the enum value
enum Color
{
    Black,
    White,
    Red,
    Yellow,
    Green
}
class Brick
{
    public int Id { get; set; }
    [MaxLength(250)]
    public string Title { get; set; } = string.Empty;
    public Color? Color { get; set; }
    public List<Tag> Tags { get; set; } = new();
    public List<BrickAvailability> BrickAvailabilities { get; set; } = new();
}
//m:n, before ef 5.0 we would have to create pivot table i.e BrickTag but this is no longer necessary, in background it will create pivot we just need collection on both side and that is sign to ef to make m:n, if we have additional values then make manul pivot(intermediate) with that values
//its possible to manul configure relations
class Tag
{
    public int Id { get; set; }
    [MaxLength(250)]
    public string Title { get; set; } = string.Empty;
    public List<Brick> Bricks { get; set; } = new();//handy when you want to insert data
}
//data structure with witch ef will put the base class and derived class in sigle table, this is called table per hierarchy bcs entire inheritence  hierarchy is stored in sigle table. Note: db dont know about inheritence. that single table will have all properties of derived class like nullable columns and ef will undrested for each entry which class is by having additional column(descriminator column(contains name of the class that obj is represented)) 
class BasePlate : Brick
{
    public int Length { get; set; }
    public int Width { get; set; }
}
class MinifigHead : Brick
{
    public bool IsDualSided { get; set; }
}

class Vendor//somaby who want to sell bricks in our store
{
    public int Id { get; set; }
    [MaxLength(250)]
    public string VendorName { get; set; } = string.Empty;
    public List<BrickAvailability> BrickAvailabilities { get; set; } = new();
}
//it has additional values, brick(m):vendor(n) + additional values
class BrickAvailability
{
    public int Id { get; set; }
    //c# reference/relation
    public Vendor Vendor { get; set; } = new();
    //foreign key val from db
    //public int VendorId { get; set; }
    public Brick Brick { get; set; } = new();
    //public int BrickId { get; set; }
   // public int AvailableAmount { get; set; }
    [Column(TypeName = "decimal(8,2)")]
    public decimal Price { get; set; }
}

#endregion

#region DbContext
class BrickContext : DbContext
{
    public BrickContext(DbContextOptions<BrickContext> options)
        : base(options)
    { }

    public DbSet<Brick> Bricks { get; set; }
    public DbSet<Tag> Tags { get; set; }
    public DbSet<Vendor> Vendors { get; set; }
    public DbSet<BrickAvailability> BrickAvailabilitys
    { get; set; }
    //accept modelBuilder as param and it is used for model configurations usinf fluentAPI, alternate to annotations
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        //and we need to add code for doing inheritencein data model to force ef to understand that we need to store derived tables too(bcs we didnt add dbsets for them) 
        modelBuilder.Entity<MinifigHead>().HasBaseType<Brick>();
        modelBuilder.Entity<BasePlate>().HasBaseType<Brick>();
        base.OnModelCreating(modelBuilder);
    }
}
class BrickContextFactory: IDesignTimeDbContextFactory<BrickContext>
{
    public BrickContext CreateDbContext(string[] args = null)
    {
        var configuration = new ConfigurationBuilder().AddJsonFile("appsettings.json").Build();

        var optionsBuilder = new DbContextOptionsBuilder<BrickContext>();
        optionsBuilder
            // Uncomment the following line if you want to print generated
            // SQL statements on the console.
            // .UseLoggerFactory(LoggerFactory.Create(builder => builder.AddConsole()))
            .UseSqlServer(configuration["ConnectionStrings:DefaultConnection"]);

        return new BrickContext(optionsBuilder.Options);
    }
} 
#endregion
