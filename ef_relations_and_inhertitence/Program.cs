// See https://aka.ms/new-console-template for more information
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

Console.WriteLine("Hello, World!");
/**
 Steps for starting from scratch with EF(up and runing)
1. nuget pack in order to project work with ef
-design - all design capabilities of ef add to your app(migrations)
-dbProvider - depending of the db you use
****if we not in asp framework we need 2 additional packeges
-extension.configiration.json - reading of connstring from appsettings.json(loosly related to ef, you cuold also type in connstring but not good)
-logging console - sql statement generated by ef
all dependencies needed for console app to work with ef
2. building data model(domain class,model) including relations
3. creation of dbcontext and dbfactory(automated in asp)
4. create db through migrations(and than fill it and query it)
 * **/

var factory = new BrickContextFactory();
using var context = factory.CreateDbContext();
//await AddData(context);
await QueryData(context);
static async Task QueryData(BrickContext context)
{
    //ef does join of these 3 tables in the background, include enforcing join of tables(i.e enfroce eager loading) and join fills related data and lists, without include relation will be null but forgnKey will be loaded but still null refrence, load obj graphs with single query using include clause, load related data with base objects/entities 
    var availabilityData = await context.BrickAvailabilitys
                                .Include(ba => ba.Brick)
                                //simple include clauses
                                .Include(ba => ba.Vendor)
                                .ToListAsync();
    foreach (var availability in availabilityData)
    {
        Console.WriteLine($"{availability.Brick.Title} avaible at {availability.Vendor.VendorName} for {availability.Price}");
    }
    var bricksWithTagsAndVendors = await context.Bricks
        //include clauses for complex navigation through connection/pivot tables
        .Include(nameof(Brick.BrickAvailabilities) + "." + nameof(BrickAvailability.Vendor))
        .Include(x => x.Tags)
        //include clauses when 1:m
        //.Where(b => b.Tags.Any(t => t.Title == "minecraft")) in this case include is not needed explicitly bcs of where it will load relation automatically(when have relation directly in linq clauses), otherwise when you dont have specific refrence in linq query but need data from related model outside of the linq query that need include
        .ToListAsync();
    foreach (var brick in bricksWithTagsAndVendors)
    {
        Console.Write($"{brick.Title}");
        if (brick.Tags.Any()) Console.Write($"({string.Join(", ", brick.Tags.Select(x => x.Title))})");
        if (brick.BrickAvailabilities.Any()) Console.Write($"({string.Join(", ", brick.BrickAvailabilities.Select(x => x.Vendor.VendorName))})");
    }
        var singleBrick = await context.Bricks.ToListAsync();
    foreach (var brick in singleBrick)
    {
        //ask ef to explicitly load related data for specific item a bit later, after the orginal query is already be done
        await context.Entry(brick).Collection(i => i.Tags).LoadAsync(); //explicitly load tahs for specific item if we need it
        Console.Write($"{brick.Title}");
        if (brick.Tags.Any()) Console.Write($"({string.Join(", ", brick.Tags.Select(x => x.Title))})");
    }
}
//static async Task AddData(BrickContext context)
//{
//    Vendor brickKing, heldDerSteine;
//    await context.AddRangeAsync(new[]
//    {
//        brickKing = new Vendor { VendorName = "Brick King" },
//        heldDerSteine = new Vendor { VendorName = "heldDerSteine" }, 
//    });
//    await context.SaveChangesAsync();
//    Tag rare, ninajago,minecraft;
//    await context.AddRangeAsync(new[]
//    {
//        rare = new Tag { Title = "rare" },
//        ninajago = new Tag { Title = "ninajago" },
//        minecraft = new Tag { Title = "minecraft" },
//    });
//    await context.SaveChangesAsync();
//    //addding obj graph to db with ef using m:n and m:1 relations
//    //building more complex obj graph in one go, adding multiple related obj even for m:n relationship in single row,obj are tight with references and will insert in all 3 tables, ef split into multiple insert statement into multiple tables
//    await context.AddAsync(new BasePlate()
//    {
//        Title = "BasePlate 16 x 16 with blue pattern",
//        Color = Color.Green,
//        Tags = new() { rare , ninajago },
//        Length = 16,
//        Width = 16,
//        BrickAvailabilities = new() 
//        {
//            new BrickAvailability { Vendor = brickKing,Price=333},
//            new BrickAvailability { Vendor = heldDerSteine, Price=5555}
//        }
//    });
//    await context.SaveChangesAsync();
//}

#region Models
//in db this will become int(ef stores enum like that) and it reflect the int behind the enum value
enum Color
{
    Black,
    White,
    Red,
    Yellow,
    Green
}
class Brick
{
    public int Id { get; set; }
    [MaxLength(250)]
    public string Title { get; set; } = string.Empty;
    public Color? Color { get; set; }
    public List<Tag> Tags { get; set; } = new();
    public List<BrickAvailability> BrickAvailabilities { get; set; } = new();
}
//m:n, before ef 5.0 we would have to create pivot table i.e BrickTag but this is no longer necessary, in background it will create pivot we just need collection on both side and that is sign to ef to make m:n, if we have additional values then make manul pivot(intermediate) with that values
//its possible to manul configure relations
class Tag
{
    public int Id { get; set; }
    [MaxLength(250)]
    public string Title { get; set; } = string.Empty;
    public List<Brick> Bricks { get; set; } = new();//handy when you want to insert data
}
//data structure with witch ef will put the base class and derived class in sigle table, this is called table per hierarchy bcs entire inheritence  hierarchy is stored in sigle table. Note: db dont know about inheritence. that single table will have all properties of derived class like nullable columns and ef will undrested for each entry which class is by having additional column(descriminator column(contains name of the class that obj is represented)) 
class BasePlate : Brick
{
    public int Length { get; set; }
    public int Width { get; set; }
}
class MinifigHead : Brick
{
    public bool IsDualSided { get; set; }
}

class Vendor//somaby who want to sell bricks in our store
{
    public int Id { get; set; }
    [MaxLength(250)]
    public string VendorName { get; set; } = string.Empty;
    public List<BrickAvailability> BrickAvailabilities { get; set; } = new();
}
//it has additional values, brick(m):vendor(n) + additional values
class BrickAvailability
{
    public int Id { get; set; }
    //c# reference/relation
    public Vendor Vendor { get; set; } = new();
    //foreign key val from db
    //public int VendorId { get; set; }
    public Brick Brick { get; set; } = new();
    //public int BrickId { get; set; }
   // public int AvailableAmount { get; set; }
    [Column(TypeName = "decimal(8,2)")]
    public decimal Price { get; set; }
}

#endregion

#region DbContext
class BrickContext : DbContext
{
    public BrickContext(DbContextOptions<BrickContext> options)
        : base(options)
    { }

    public DbSet<Brick> Bricks { get; set; }
    public DbSet<Tag> Tags { get; set; }
    public DbSet<Vendor> Vendors { get; set; }
    public DbSet<BrickAvailability> BrickAvailabilitys
    { get; set; }
    //accept modelBuilder as param and it is used for model configurations usinf fluentAPI, alternate to annotations
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        //and we need to add code for doing inheritencein data model to force ef to understand that we need to store derived tables too(bcs we didnt add dbsets for them) 
        modelBuilder.Entity<MinifigHead>().HasBaseType<Brick>();
        modelBuilder.Entity<BasePlate>().HasBaseType<Brick>();
        base.OnModelCreating(modelBuilder);
    }
}
class BrickContextFactory: IDesignTimeDbContextFactory<BrickContext>
{
    public BrickContext CreateDbContext(string[] args = null)
    {
        var configuration = new ConfigurationBuilder().AddJsonFile("appsettings.json").Build();

        var optionsBuilder = new DbContextOptionsBuilder<BrickContext>();
        optionsBuilder
            // Uncomment the following line if you want to print generated
            // SQL statements on the console.
            .UseLoggerFactory(LoggerFactory.Create(builder => builder.AddConsole()))
            .UseSqlServer(configuration["ConnectionStrings:DefaultConnection"]);

        return new BrickContext(optionsBuilder.Options);
    }
} 
#endregion
